#!/usr/bin/bash

init() {
    true
    DMENU="dmenu"
}

ru() {
    if [ -d "$cachedir" ]; then
        cache=$cachedir/dmenu_run
    else
        cache=$HOME/.dmenu_cache # if no xdg dir, fall back to dotfile in ~
    fi
    (
        IFS=:
        if stest -dqr -n "$cache" $PATH; then
            stest -flx $PATH | sort -u | tee "$cache" | $DMENU "$@"
        else
            $DMENU "$@" < "$cache"
        fi
    ) | ${SHELL:-"/bin/sh"} &
}

re() {
    terminal="urxvtc -e"
    max_recent=199 # Number of recent commands to track

    cache_dir="${XDG_CACHE_HOME:-$HOME/.cache}/dmenu-recent"
    recent_cache="$cache_dir/recent"
    rest_cache="$cache_dir/all"
    known_types=" background terminal terminal_hold "

    config_dir="${XDG_CONFIG_HOME:-$HOME/.config}/dmenu-recent"
    mkdir -p "$cache_dir"
    mkdir -p "$config_dir"
    touch "$recent_cache"

    # Without this, it won't remember $type
    GREP_OPTIONS='--color=never'

    IFS=:
    if stest -dqr -n "$rest_cache" $PATH 2>/dev/null; then
        stest -flx $PATH | sort -u | grep -vf "$recent_cache" > "$rest_cache"
    fi

    IFS=" "
    cmd=$(cat "$recent_cache" "$rest_cache" | $DMENU -p Execute: "$@") || exit

    if ! grep -qx "$cmd" "$recent_cache" &> /dev/null; then
        grep -vx "$cmd" "$rest_cache" > "$rest_cache.$$"
        mv "$rest_cache.$$" "$rest_cache"
    fi

    echo "$cmd" > "$recent_cache.$$"
    grep -vx "$cmd" "$recent_cache" | head -n "$max_recent" >> "$recent_cache.$$"
    mv "$recent_cache.$$"  "$recent_cache"

    # Figure out how to run the command based on the command name, disregarding
    # arguments, if any.
    word0=${cmd%% *}
    match="^$word0$"

    get_type () {
        while type=$(echo $known_types | xargs -n1 | $DMENU -p Type:); do
            [[ $known_types =~ " $type " ]] || continue
            echo "$word0" >> "$config_dir/$type"
            break
        done
        echo $type
    }

    if ! type=$(grep -lx "$match" -R "$config_dir"); then
        type=$(get_type)
    else 
        type=${type##*/}
        if ! [[ $known_types =~ " $type " ]]; then
            rm "$config_dir/$type"
            type=$(get_type)
        fi
    fi

    [[ "$type" = "background" ]] && exec $cmd
    [[ "$type" = "terminal" ]] && exec $terminal "$cmd"
    [[ "$type" = "terminal_hold" ]] && exec $terminal sh -c "$cmd && echo Press Enter to kill me... && read line"
}

# can reuse fm
df() {
    f=$(find $ARCH_HOME -type f -regextype posix-extended -regex ".*" | $DMENU -p "Dotfiles: ")
    # TODO hack! open vim in tmux window #9
    test ! -z $f && tmux new-window -t :9 && tmux send-keys -t :9 "vim $f" enter
}

kl() {
    ps -ef | $DMENU -p "Processes: " | awk '{print $2}' | xargs kill -9 &>/dev/null
}

sy() {
    f=$(find /etc/systemd/ /usr/lib/systemd ~/.config/systemd -type f -regextype posix-extended -regex ".*.service$|.*.conf$" | $DMENU -p "Systemd: ")
    #find /etc/systemd/ /usr/lib/systemd ~/.config/systemd -type f -regextype posix-extended ! -regex ".*.service$|.*.socket$|.*.target$|.*.busname$|.*.conf$|.*-\<[a-z]+\>$"  | $DMENU -p "Systemd: "
    # TODO hack # open vim in tmux window #9
    test ! -z $f && tmux new-window -t :9 && tmux send-keys -t :9 "sudo vim $f" enter
}

sw() {
    wmctrl_output=$(wmctrl -lx) # get list of all windows, and their count
    win_count=$(echo "$wmctrl_output" | wc -l)

    # get rid of the hostname and the number in the 2nd column
    hostname=$(uname -n)
    win_list=$(echo "$wmctrl_output" | sed -r -e 's/[^@]'$hostname'//' | sed -r -e 's/ [0-9][0-9]? / /')

    # select a window ($target) and extract its id ($target_id)
    target=$(echo "$win_list" | $DMENU -l $win_count -p "Switch to: ")
    target_id=$(echo "$target" | cut -d' ' -f1)

    # switch to target window
    cmd="wmctrl -i -a \"$target_id\""
    eval "$cmd"
}

fm () {
    [ -z $1 ] && file="." || file=$1 ; cd $file

    while [ "$file" ]; do
        file=$(ls -1a --group-directories-first | sed 1d | dmenu -l 10 -p "Blader: $(basename $(pwd))")
        if [ -e "$file" ]; then
            owd=$(pwd)
            if [ -d "$file" ]; then
                cd "$file"
            else [ -f "$file" ]
                if which xdg-open &> /dev/null; then
                    exec xdg-open "$owd/$file" &
                    unset file
                fi
            fi
        fi
    done
}

main() {
    [ $# -eq 0 ] && dmenu && exit $?

    init
    case $1 in
        ru) ru ;;
        re) re ;;
        df) df ;;
        kl) kl ;;
        sy) sy ;;
        sw) sw ;;
        fm) fm $2;;
        *) printf "usage: dmenu [ run | rec | dfs | kl | sys | swi | fm [path] ]\n" ;;
    esac
}

main $@
